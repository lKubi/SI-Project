// src/java/domotic/AStar.java
package domotic;

import jason.environment.grid.GridWorldModel;
import jason.environment.grid.Location;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

/**
 * Implements the A* pathfinding algorithm for the HouseModel environment.
 */
public class AStar {

    /**
     * Calculates the Manhattan distance between two locations.
     * Used as the heuristic function (h) in A*.
     *
     * @param a The first location.
     * @param b The second location.
     * @return The Manhattan distance.
     */
    private static int manhattanDistance(Location a, Location b) {
        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
    }

    /**
     * Reconstructs the path from the start node to the goal node
     * using the 'cameFrom' map generated by the A* search.
     *
     * @param cameFrom A map where cameFrom.get(node) is the node preceding it on the cheapest path known.
     * @param current The goal node.
     * @return A list of Locations representing the path from start to goal.
     */
    private static List<Location> reconstructPath(Map<Location, Location> cameFrom, Location current) {
        List<Location> totalPath = new ArrayList<>();
        totalPath.add(current);
        while (cameFrom.containsKey(current)) {
            current = cameFrom.get(current);
            totalPath.add(current);
        }
        Collections.reverse(totalPath);
        return totalPath;
    }

    /**
     * Finds the shortest path between two locations using the A* algorithm.
     *
     * @param model The HouseModel instance containing grid information and movement rules.
     * @param Ag    The ID of the agent trying to move (used for canMoveTo check).
     * @param start The starting location.
     * @param dest  The destination location.
     * @return A List of Locations representing the path from start to dest,
     * or an empty list if no path is found.
     */
    public static List<Location> findPath(HouseModel model, int Ag, Location start, Location dest) {

        Map<Location, Location> cameFrom = new HashMap<>();
        Map<Location, Integer> gScore = new HashMap<>();
        Map<Location, Integer> fScore = new HashMap<>();

        Comparator<Location> fScoreComparator = Comparator.comparingInt(loc -> fScore.getOrDefault(loc, Integer.MAX_VALUE));
        PriorityQueue<Location> openSet = new PriorityQueue<>(fScoreComparator);

        Set<Location> closedSet = new HashSet<>();

        gScore.put(start, 0);
        fScore.put(start, manhattanDistance(start, dest));
        openSet.add(start);

        while (!openSet.isEmpty()) {
            Location current = openSet.poll();

            if (current.equals(dest)) {
                return reconstructPath(cameFrom, current);
            }

            closedSet.add(current);

            int[] dx = {0, 0, 1, -1};
            int[] dy = {1, -1, 0, 0};

            for (int i = 0; i < 4; i++) {
                int nextX = current.x + dx[i];
                int nextY = current.y + dy[i];
                Location neighbor = new Location(nextX, nextY);

        
                boolean isValidNeighbor = false;
                if (!neighbor.equals(dest)) {
                    if (model.canMoveTo(Ag, nextX, nextY)) {
                         isValidNeighbor = true;
                    }
                } else {
                    if (nextX >= 0 && nextX < model.getWidth() && nextY >= 0 && nextY < model.getHeight()) {
                        if (!model.hasObject(GridWorldModel.OBSTACLE, nextX, nextY)) {
                            isValidNeighbor = true;
                        }
                    }
                }

                if (!isValidNeighbor) {
                    continue;
                }

                if (closedSet.contains(neighbor)) {
                    continue;
                }

                int tentativeGScore = gScore.getOrDefault(current, Integer.MAX_VALUE) + 1;

                if (tentativeGScore < gScore.getOrDefault(neighbor, Integer.MAX_VALUE)) {
                    cameFrom.put(neighbor, current);
                    gScore.put(neighbor, tentativeGScore);
                    fScore.put(neighbor, tentativeGScore + manhattanDistance(neighbor, dest));

                    if (!openSet.contains(neighbor)) {
                        openSet.add(neighbor);
                    } else {
                        openSet.remove(neighbor);
                        openSet.add(neighbor);
                    }
                }
            }
        }

        System.err.println("A* Warning: No path found from " + start + " to " + dest + " for agent " + Ag);
        return new ArrayList<>();
    }
}